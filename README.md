# dix - Dependency Injection for Go

`dix` is a dependency injection code generator for Go. It uses annotations in your code comments to automatically generate the dependency wiring for your project. This helps you write modular, testable, and maintainable Go applications.

## Getting Started

To use `dix`, you need to add annotations to your Go source files. Then, you can run the `dix` generator to create the dependency injection container.

### 1. Annotate your code

Add annotations to your Go files to define your components and their dependencies.

```go
package main

// @factory: NewServer -> server
func NewServer(db *Database) *Server {
    return &Server{db: db}
}

// @wire: NewServer(database)
```

### 2. Generate the DI container

Create a `main.go` file to run the `dix` generator:

```go
package main

import (
    "fmt"
    "log"

    "github.com/smtdfc/dix"
)

func main() {
    code, err := dix.ScanProjectAndGenerateDI(".")
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(code)
}
```

Run the generator:

```sh
go run main.go > dix.gen.go
```

This will create a `dix.gen.go` file with the generated dependency injection container.

## Annotations

`dix` uses the following annotations to define the dependency injection container:

### `@factory`

The `@factory` annotation marks a function as a factory for a component.

**Syntax:** `@factory: <function_name> -> <alias>`

- `<function_name>`: The name of the factory function.
- `<alias>`: A unique alias for the component.

**Example:**

```go
// @factory: NewDatabase -> database
func NewDatabase() *Database {
    // ...
}
```

### `@wire`

The `@wire` annotation specifies the dependencies for a factory.

**Syntax:** `@wire: <function_name>(<dep1_alias>, <dep2_alias>, ...)`

- `<function_name>`: The name of the factory function.
- `<dep_alias>`: The alias of a dependency.

**Example:**

```go
// @factory: NewServer -> server
func NewServer(db *Database) *Server {
    // ...
}

// @wire: NewServer(database)
```

#### Standalone Dependencies

You can create a new instance of a dependency instead of reusing one from the container by prefixing the dependency alias with `^`.

**Example:**

```go
// @wire: NewServer(^database)
```

This will create a new `Database` instance every time `NewServer` is called.

### `@final`

The `@final` annotation marks a component as "final", meaning it cannot be a dependency of another component. This is useful for root-level components that are not used by other components.

**Syntax:** `@final: <alias>`

- `<alias>`: The alias of the component.

**Example:**

```go
// @final: server
```

### `@disable`

The `@disable` annotation disables a component, preventing it from being included in the dependency injection container.

**Syntax:** `@disable: <alias>`

- `<alias>`: The alias of the component.

**Example:**

```go
// @disable: server
```

## Complete Example

Here is a complete example of how to use `dix` in a Go project.

**`main.go`**

```go
package main

import "fmt"

type Database struct{}

func (db *Database) Query() string {
    return "query result"
}

// @factory: NewDatabase -> database
func NewDatabase() *Database {
    return &Database{}
}

type Server struct {
    db *Database
}

func (s *Server) Start() {
    fmt.Println(s.db.Query())
}

// @factory: NewServer -> server
func NewServer(db *Database) *Server {
    return &Server{db: db}
}

// @wire: NewServer(database)
// @final: server

func main() {
    // This function is the entry point for the application.
    // The generated dix.Root() function will initialize and start the server.
    // To use it, you would typically call it from here,
    // but since the generated code is not available at compile time,
    // you will need a separate entry point for the generator.
}
```

**`tools/dix/main.go`** (Generator entry point)

```go
package main

import (
    "fmt"
    "io/ioutil"
    "log"

    "github.com/smtdfc/dix"
)

func main() {
    code, err := dix.ScanProjectAndGenerateDI(".")
    if err != nil {
        log.Fatal(err)
    }

    err = ioutil.WriteFile("dix.gen.go", []byte(code), 0644)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println("dix.gen.go generated successfully.")
}
```

**Generate the code:**

```sh
go run ./tools/dix/main.go
```

**`dix.gen.go`** (Generated file)

```go
// Code generated by dix. DO NOT EDIT.
package main

import (
	"github.com/smtdfc/dix"
)

func Root() {
	// ... generated code ...
}
```

Now you can build and run your application. The `dix.Root()` function will be available to initialize your application's components. You would typically create another `main.go` for your application build that calls `Root()`.
